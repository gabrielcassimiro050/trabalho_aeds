/* autogenerated by Processing revision 1293 on 2024-05-11 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class trabalho extends PApplet {



tile[][] grid;
int r, c; //Tamanho da grid --- rows e columns (fileiras e colunas)
float l, h; //Tamanho de cada espaço --- length e height (comprimento e altura)
float xOffset, yOffset; //Offset da grid

int tempoFrame, frame;

int tempo; //Tempo desde do início do jogo
int tempoGame; //Tempo em jogo
int tempoMax; //Tempo máximo de jogo

float escala = .1f; //Escala do Noise
float seed; //Seed do Noise
float seedRange = 10000; //Raio da seed

float previewX, previewY; //Posição da preview
float previewTamanhoX, previewTamanhoY; //Tamanho da preview

//Faça o download da library Processing Sound para funcionar
SoundFile musica, musicaFinal;
SoundFile[] coleta;
PitchDetector pitch;

PImage[] itemSprites;
PImage[] arvoreSprites;
PImage[] gramaSprites;
PImage[] terraSprites;
PImage play, exitSprite, back, start, seedSprite, bigChecked, bigUnchecked, cSprite, rSprite, reset;
PImage playerSprite;
PImage telaDeCarregamento;
PImage placarDeTempo, placarDePontuacao;
PImage moldura, molduraPontuacao;
PFont pixelFont;

player player;
item item;
menu menuInicial;
menu menuStart;
botao restart, exit;

boolean contando;
boolean mapaExpandido;
boolean game;
boolean loading;
boolean paused;
boolean fim;

long instanteInicial, instanteAnterior;

int colisao[] = {2}; //Árvore

int bg = 0xFF060139; //Background
float animacaoInicial = 0;

//Garantem que as coordenadas estejam dentro da grid
public int xC(int x) {
  return (x+r)%r;
}
public int yC(int y) {
  return (y+c)%c;
}

//Funções da Grid---------------------------------------------------------------------------------------

//Implementação que permite adicionar outros obstáculos
public boolean checarColisao(int x, int y) {
  for (int i = 0; i < colisao.length; ++i) {
    if (grid[x][y].tipo==colisao[i]) return false;
  }
  return true;
}

public tile[][] criarGrid() {
  tile[][] aux = new tile[r][c];
  for (int x = 0; x < r; ++x) {
    for (int y = 0; y < c; ++y) {
      aux[x][y] = new tile(x, y, random(1)<.9f ? random(1)>.8f ? 1 : 0 : 2); //Gera Árvores aleatórias
      if ((aux[x][y].tipo==1 || aux[x][y].tipo==0) && random(1)>.5f && mapaExpandido) aux[x][y] = new tile(x, y, (int)map(round(noise(x*escala, y*escala, seed)), 0, 1, 0, 2)); //Gera uma camada de noise de árvores
      if (dist(x*l+l/2.0f, y*h+h/2.0f, width/2.0f, height/2.0f)<=log(width+height)*10) aux[x][y] = new tile(x, y, 1); //Limpa área ao redor do personagem
    }
  }
  return aux;
}


//Do centro do mapa, preenche o mapa com Aux se o espaço for Grama
//Apenas preenche espaços que são alcançáveis
public void descobreVazios(int x, int y, int t) {
  //O pior caso nesse cenário seria O(r*c), porém o software não permite muitas recursões, se os valores fossem 250 (o máximo permitido), teriamos 62500 recursões, o que é inviável
  //Então apliquei uma conta que daria um número menor que não é tão eficiente, o que pode gerar aglomerados de árvores em certas ocasiões, devido a incapacidade do algoritmo de alcançar essas áreas
  if (t<(r*2+c*2)*2) {
    ++t;
    for (int i = -1; i <= 1; ++i) {
      if (grid[xC(x+i)][y].tipo != 2 && grid[xC(x+i)][y].tipo != 4) {
        grid[xC(x+i)][y] = new tile(xC(x+i), y, 4); //Adiciona Aux a todo tile de Grama
        descobreVazios(xC(x+i), y, t);  //Chama a função com essa nova posição
      }
    }
    for (int i = -1; i <= 1; ++i) {
      if (grid[x][yC(y+i)].tipo != 2 && grid[x][yC(y+i)].tipo != 4) {
        grid[x][yC(y+i)] = new tile(x, yC(y+i), 4); //Adiciona Aux a todo tile de Grama
        descobreVazios(x, yC(y+i), t);  //Chama a função com essa nova posição
      }
    }
  }
}

//Troca os espaços de Aux com Grama e aqueles de Grama que não foram alcançados por Árvore
//Eliminando os espaços impossíveis de chegar
//Adiciona Terra
public void preparaGrid() {
  float seedAux = random(1000);
  for (int x = 0; x < r; ++x) {
    for (int y = 0; y < c; ++y) {
      if (mapaExpandido) {
        if (grid[x][y].tipo == 1 || grid[x][y].tipo == 0) grid[x][y] = new tile(x, y, 2); //Troca Grama por Árvore
        if (grid[x][y].tipo == 4) grid[x][y] = new tile(x, y, random(1)>.8f ? 1 : 0); //Troca Aux por Grama
      }
      if (dist(x*l+l/2.0f, y*h+h/2.0f, width/2.0f, height/2.0f)<=log(width+height)*10) grid[x][y] = new tile(x, y, 3); //Adiciona Terra ao redor do centro
      if (grid[x][y].tipo == 1 || grid[x][y].tipo == 0) grid[x][y] = new tile(x, y, round(noise(x*escala, y*escala, seedAux))==0 ? random(1)>.8f ? 1 : 0 : 3); //Adiciona uma camada de noise de Terra
    }
  }
}

//Agrupamento das três funções acima
public void geraGrid() {
  grid = criarGrid();
  if (mapaExpandido) {
    descobreVazios(floor(r/2.0f), floor(c/2.0f), 0);
  }
  preparaGrid();
}

//Mostra a grid
public void showGrid() {
  background(bg);
  for (int x = 0; x < r; ++x) {
    for (int y = 0; y < c; ++y) {
      grid[x][y].show();
    }
  }
}

public void showPreview() {
  //Mostra a preview do mapa
  float previewL = previewTamanhoX/(float)r, previewH = previewTamanhoY/(float)c;
  float previewXOffset = 0, previewYOffset = 0;
  
  fill(0xFF82441A);
  rect(previewX-previewTamanhoX/30.0f, previewY-previewTamanhoY/30.0f, previewTamanhoX+previewTamanhoX/15.0f, previewTamanhoY+previewTamanhoY/15.0f);  
  
  if (c>r) {
    previewL*=(r/(float)c);
    previewXOffset = (previewTamanhoX-r*previewL)/2.0f;
  }
  if (r>c) {
    previewH*=(c/(float)r);
    previewYOffset = (previewTamanhoY-c*previewH)/2.0f;
  }

  for (int x = 0; x < r; ++x) {
    for (int y = 0; y < c; ++y) {
      noStroke();
      switch(grid[x][y].tipo) {
      case 0:
        fill(0xFF74FF75);
        break;
      case 1:
        fill(0xFF74FF75);
        break;
      case 2:
        fill(0xFF21CB77);
        break;
      case 3:
        fill(0xFFFFFF95);
        break;
      }
      rect(previewX+x*previewL+previewXOffset, previewY+y*previewH+previewYOffset, previewL, previewH);
    }
  }
  
  fill(0xFF82441A);
  rect(previewX+5*previewTamanhoX/4.0f-previewTamanhoX/30.0f, previewY-previewTamanhoY/30.0f, previewTamanhoX+previewTamanhoX/15.0f, previewTamanhoY+previewTamanhoY/15.0f);
  
  noStroke();
  fill(0xFF4BC7FF);
  rect(previewX+5*previewTamanhoX/4.0f, previewY, previewTamanhoX, previewTamanhoY);
  fill(0xFF0EED65);
  rect(previewX+5*previewTamanhoX/4.0f, previewY+4*previewTamanhoY/5.0f, previewTamanhoX+1, previewTamanhoY/5.0f);
  image(playerSprite, previewX+3.4f*previewTamanhoX/2.4f, 4*previewY/3.0f, previewTamanhoX/1.5f, previewTamanhoY/1.5f);
  noFill();
  strokeWeight(3);
  rect(previewX, previewY, previewTamanhoX, previewTamanhoY);
  rect(previewX+5*previewTamanhoX/4.0f, previewY, previewTamanhoX, previewTamanhoY);
  strokeWeight(1);
}
//-------------------------------------------------------------------------------------------------------


//Valor do item
public int valorAleatorio() {
  return ceil(random(10));
}

public PVector posicaoAleatoria() {
  return new PVector(floor(random(r)), floor(random(c)));
}

//Transforma ms em s
public int segundos(long i, long f) {
  return floor((f-i)/(float)1000);
}

//Movimentação
public void keyPressed() {
  if (game) {
    switch(key) {
    case 'd':
      player.right = true;
      break;
    case 'a':
      player.left = true;
      break;
    case 'w':
      player.up = true;
      break;
    case 's':
      player.down = true;
      break;
    case 'e':
      if (player.abrirInventario) {
        player.abrirInventario = false;
        showGrid();
      } else {
        player.abrirInventario = true;
      }
      break;
    }
    switch(keyCode) {
    case RIGHT:
      player.right = true;
      break;
    case LEFT:
      player.left = true;
      break;
    case UP:
      player.up = true;
      break;
    case DOWN:
      player.down = true;
      break;
    }
  }
}

public void keyReleased() {
  for (int i = 0; i < menuStart.textBoxes.size(); ++i) {
    textBox textBox = menuStart.textBoxes.get(i);
    if (textBox.click) {
      //Apaga a string
      if (keyCode==BACKSPACE) textBox.txt = new String();

      //Adiciona o caractere à string
      if (textBox.txt!=null && Character.isDigit(key)) {
        if (!textBox.txt.equals("0")) {
          textBox.txt = textBox.txt.concat(Character.toString(key));
        } else {
          textBox.txt = Character.toString(key);
        }
      } else if (keyCode!=ENTER) {
        textBox.txt = "0";
      }

      //Valida a string, adiciona aos valores de r e c e calcula as novas dimensões de cada espaço no mapa
      if (keyCode==ENTER) {
        if (textBox.txt=="0") textBox.txt = "1";
        textBox.txt = Integer.valueOf(textBox.txt)<=250 ? textBox.txt : "250";
        if (textBox.nome.equals("R")) r = Integer.valueOf(textBox.txt);
        if (textBox.nome.equals("C")) c = Integer.valueOf(textBox.txt);
        frame = floor(10/floor(log(r+c)));
        l = width/(float)r;
        h = height/(float)c;
        geraGrid();
      }
    }
  }
  if (game) {
    switch(key) {
    case 'd':
      player.right = false;
      break;
    case 'a':
      player.left = false;
      break;
    case 'w':
      player.up = false;
      break;
    case 's':
      player.down = false;
      break;
    }
    switch(keyCode) {
    case RIGHT:
      player.right = false;
      break;
    case LEFT:
      player.left = false;
      break;
    case UP:
      player.up = false;
      break;
    case DOWN:
      player.down = false;
      break;
    }
  }
}

public void mousePressed() {
  if (menuInicial.visivel) {
    for (int i = 0; i < menuInicial.botoes.size(); ++i) {
      botao botao = menuInicial.botoes.get(i);
      botao.clicked();
    }
  }
  if (menuStart.visivel) {
    for (int i = 0; i < menuStart.botoes.size(); ++i) {
      botao botao = menuStart.botoes.get(i);
      botao.clicked();
    }
    for (int i = 0; i < menuStart.checkBoxes.size(); ++i) {
      checkBox checkBox = menuStart.checkBoxes.get(i);
      checkBox.clicked();
    }
    for (int i = 0; i < menuStart.textBoxes.size(); ++i) {
      textBox textBox = menuStart.textBoxes.get(i);
      textBox.clicked();
      if (textBox.click) textBox.txt = "0";
    }
  }

  restart.clicked();
}

public void mouseReleased() {

  //Menu Inicial--------------------------------
  if (menuInicial.visivel) {
    botao game = menuInicial.getBotao("Game");
    botao sair = menuInicial.getBotao("Sair");

    if (game.click) {
      menuInicial.visivel = false;
      menuStart.visivel = true;
      game.click = false;
      background(bg);
    }
    if (sair.click) {
      exit();
    }
  }
  //--------------------------------------------

  //Menu Start----------------------------------
  if (menuStart.visivel) {
    botao start = menuStart.getBotao("Start");
    botao voltar = menuStart.getBotao("Voltar");
    botao randomSeed = menuStart.getBotao("Random Seed");
    checkBox expandido = menuStart.getcheckBox("Expandido");

    if (start.click) {
      menuStart.visivel = false;
      background(bg);
      imageMode(CENTER);
      image(telaDeCarregamento, width/2.0f, height/2.0f, 320, 160);
      game = true;
      start.click = false;
    }

    if (voltar.click) {
      menuStart.visivel = false;
      menuInicial.visivel = true;
      voltar.click = false;
      background(bg);
    }

    if (expandido.click) {
      if (!mapaExpandido) {
        mapaExpandido = true;
        geraGrid();
      }
    } else {
      if (mapaExpandido) {
        mapaExpandido = false;
        geraGrid();
      }
    }

    if (randomSeed.click) {
      seed = random(seedRange);
      geraGrid();
      randomSeed.click = false;
    }
  }
  //--------------------------------------------

  if (restart.click) {
    background(bg);
    imageMode(CORNER);
    setup();
    restart.click = false;
  }
  
  if(exit.click){
    exit();
  }
}

public void setup() {
  /* size commented out by preprocessor */;
  background(bg);
  
  r = 10;
  c = 10;
  
  tempoFrame = 0;
  frame = floor(10/floor(log(r+c)));
  
  contando = false;
  mapaExpandido = false;
  game = false;
  loading = true;
  paused = false;
  fim = false;

  tempo = 0;
  tempoGame = 0;
  tempoMax = 1;

  //Tela de Loading Inicial
  noStroke();
  rectMode(CENTER);
  rect(width/2.0f, height/2.0f, width/4.0f, width/4.0f);
  rectMode(CORNER);

  //Carrega os sprites dos botões
  play = new PImage();
  play = loadImage("play.png");
  exitSprite = new PImage();
  exitSprite = loadImage("exit.png");
  back = new PImage();
  back = loadImage("back.png");
  start = new PImage();
  start = loadImage("start.png");
  seedSprite = new PImage();
  seedSprite = loadImage("seed.png");
  bigUnchecked = loadImage("big_unchecked.png");
  bigChecked = loadImage("big_checked.png");
  cSprite = new PImage();
  cSprite = loadImage("c.png");
  rSprite = new PImage();
  rSprite = loadImage("r.png");
  reset = new PImage();
  reset = loadImage("reset.png");

  l = width/(float)r;
  h = height/(float)c;

  //Define o tamanho dos menus e suas posições
  float mundoTamanhoX = width/1.5f, mundoTamanhoY = height/1.5f;
  float mundoX = (width-mundoTamanhoX)/2.0f, mundoY = (height-mundoTamanhoY)/2.0f;

  //Define as proporções da preview
  previewX = (mundoTamanhoX/2.0f-mundoTamanhoX/2.5f)/2+mundoX;
  previewY = mundoY*.9f+(mundoTamanhoY/2.0f-mundoTamanhoY/2.5f)/2;
  previewTamanhoX = mundoTamanhoX/2.5f;
  previewTamanhoY = mundoTamanhoY/2.5f;

  //Define o menu Inicial
  float inicialX = (width-width/2.0f)/2.0f, inicialY = height/1.7f;
  menuInicial = new menu(inicialX, inicialY, width/4.0f, height/4.0f, true);
  menuInicial.addBotao(inicialX, inicialY, width/2.0f, height/8.0f, true, "Game", play);
  menuInicial.addBotao(inicialX, inicialY+height/6.0f, width/2.0f, height/8.0f, true, "Sair", exitSprite);

  //Define o menu de Start e seus acessórios se baseando na posição da preview
  menuStart = new menu(mundoX, mundoY, mundoTamanhoX, mundoTamanhoY, false);
  menuStart.addBotao(previewX, previewY, previewX+r*(previewX/previewTamanhoX), previewY+c*(previewY/previewTamanhoY), false, "Mundo", null); //Placeholder da preview
  menuStart.addcheckBox(previewX, previewY+5*mundoTamanhoY/12.0f+mundoTamanhoY/45.0f, mundoTamanhoX/2.5f, mundoTamanhoY/10.0f, true, "Expandido", bigUnchecked, bigChecked);
  menuStart.addBotao(previewX, previewY+31*mundoTamanhoY/60.0f+mundoTamanhoY/150.0f+mundoTamanhoY/45.0f, mundoTamanhoX/2.5f, mundoTamanhoY/10.0f, true, "Random Seed", seedSprite);

  menuStart.addtextBox(previewX, previewY+37*mundoTamanhoY/60.0f+mundoTamanhoY/150.0f*2+mundoTamanhoY/45.0f, mundoTamanhoX/2.5f, mundoTamanhoY/10.0f, true, "R", "10", rSprite);
  menuStart.addtextBox(previewX, previewY+43*mundoTamanhoY/60.0f+mundoTamanhoY/150.0f*3+mundoTamanhoY/45.0f, mundoTamanhoX/2.5f, mundoTamanhoY/10.0f, true, "C", "10", cSprite);

  menuStart.addBotao(previewX+mundoTamanhoX/2.0f, mundoY+31*mundoTamanhoY/40.0f-mundoTamanhoY/10.7f, mundoTamanhoX/2.5f, mundoTamanhoY/10.0f, true, "Start", start);
  menuStart.addBotao(previewX+mundoTamanhoX/2.0f, mundoY+7*mundoTamanhoY/8.0f-mundoTamanhoY/11.2f, mundoTamanhoX/2.5f, mundoTamanhoY/10.0f, true, "Voltar", back);

  restart = new botao((width-width/1.5f)/2.4f+width/1.5f/2.0f, (height-height/1.5f)/4.0f+height/2.0f, width/1.5f/2.0f, height/1.5f/8.0f, false, "restart", reset);
  exit = new botao((width-width/1.5f)/2.4f+width/1.5f/2.0f, (height-height/1.5f)/4.0f+height/2.0f+height/1.5f/7.0f, width/1.5f/2.0f, height/1.5f/8.0f, false, "exit", exitSprite);  
  
  //Cria o que servirá para a preview inicial
  geraGrid();

  //Carrega os sons
  musica = new SoundFile(this, "music.mp3");
  musicaFinal = new SoundFile(this, "end_music.mp3");
  coleta = new SoundFile[2];
  for (int i = 0; i < coleta.length; ++i) coleta[i] = new SoundFile(this, "collect_"+i+".mp3");

  //Carrega tela de loading
  telaDeCarregamento = new PImage();
  telaDeCarregamento = loadImage("loading.png");

  //Carrega player
  playerSprite = new PImage();
  playerSprite = loadImage("ladrao.png");

  //Carrega os sprites dos itemSprites
  itemSprites = new PImage[10];
  for (int i = 0; i < itemSprites.length; ++i) itemSprites[i] = loadImage("item_"+i+".png");

  //Carrega fonte
  pixelFont = createFont("Minecraft.ttf", 20);
  textFont(pixelFont);

  //Toca a musica
  musica.play();
  musica.loop();

  instanteInicial = millis();
  instanteAnterior = 0;
  loading = true;
}

public void draw() {
  if (game) {

    //Carregamento
    if (loading) {
      background(bg);
      int x = floor(r/2.0f);
      int y = floor(c/2.0f);
      player = new player(new PVector(x, y));
      item = new item();

      //Carrega os sprites dos tiles
      arvoreSprites = new PImage[11];
      for (int i = 0; i < arvoreSprites.length; ++i) arvoreSprites[i] = loadImage("tree_"+i+".png");
      gramaSprites = new PImage[2];
      for (int i = 0; i < gramaSprites.length; ++i) gramaSprites[i] = loadImage("grass_"+i+".png");
      terraSprites = new PImage[1];
      for (int i = 0; i < terraSprites.length; ++i) terraSprites[i] = loadImage("dirt_"+i+".png");


      //Carrega os sprites do tempo e score
      placarDeTempo = new PImage();
      placarDePontuacao = new PImage();
      moldura = new PImage();
      molduraPontuacao = new PImage();
      placarDeTempo = loadImage("time.png");
      placarDePontuacao = loadImage("score.png");
      moldura = loadImage("frame.png");
      molduraPontuacao = loadImage("frameScore.png");

      //Define e coloca input no PitchDetector (Detecta a nota fundamental)
      //Serve para que o personagem se balançe no ritmo da música
      pitch = new PitchDetector(this, 0);
      pitch.input(musica);

      //Calcula o offset do mapa
      //Evita que haja distorções no mapa
      if (c>r) {
        l*=(r/(float)c);
        xOffset = (width-r*l)/2.0f;
      }
      if (r>c) {
        h*=(c/(float)r);
        yOffset = (height-c*h)/2.0f;
      }

      showGrid();
      loading = false;
    }


    //Define a velocidade do player, aplicando um delay ao input de movimento
    if (tempoFrame%frame==0 && !paused) player.update();

    //Gera o item enquanto não estiver pausado e 10 segundos passaram
    if (tempoGame%10 == 0 && !contando) {
      item.zeraItem();
      item.geraItem();
    }

    //Conta o tempo de jogo enquanto não estiver pausado e 1 segundo passar
    if (tempo%1 == 0 && !contando && !paused) {
      tempoGame++;
    }

    //Checa se o jogo ainda não acabou
    if (tempoMax-tempoGame<=0 && contando) {
      player.animacao = 0;
      game = false;
    }

    //Mostra o player e o item
    if (!player.abrirInventario) item.show();
    player.show();

    //Checa se o inventário está aberto e pausa o jogo
    if (!player.abrirInventario) {
      paused = false;
      contando = false;
      image(placarDeTempo, width*.08f, height*.04f, width*.16f, height*.08f);
      image(placarDePontuacao, width-width*.08f, height*.04f, width*.16f, height*.08f);
      fill(0xFF82441A);
      text((tempoMax-tempoGame)/60+":"+nf((tempoMax-tempoGame)%60, 2), width/25.0f, height/20.0f);
      text(nf(player.score, 4), width-width/10.0f, height/20.0f);
    } else {
      contando = true;
      paused = true;
      fill(255);
      text((tempoMax-tempoGame)/60+":"+nf((tempoMax-tempoGame)%60, 2), width/25.0f, height-height/20.0f);
      text(nf(player.score, 4), width-width/10.0f, height-height/20.0f);
    }

    //Conta os segundos
    long instanteAtual = millis();
    if (segundos(instanteInicial, instanteAtual)-segundos(instanteInicial, instanteAnterior)==1) {
      ++tempo;
      contando = false;
    } else {
      contando = true;
    }
    instanteAnterior = millis();

    ++tempoFrame;
  } else {
    if (menuInicial.visivel) {
      background(bg);
      menuInicial.show();
      imageMode(CENTER);
      pushMatrix();
      translate(width/2.5f, height/2.5f);
      rotate(radians(10));
      image(playerSprite, 0, sin(animacaoInicial)*5, width/3.5f, height/3.5f);
      image(itemSprites[2], width/3, -height/5+sin(animacaoInicial-10)*5, width/10, height/10);
      image(itemSprites[8], width/8, -height/4+sin(animacaoInicial-20)*5, width/7, height/7);
      popMatrix();
      imageMode(CORNER);
      animacaoInicial += .2f;
    }

    if (menuStart.visivel) {
      background(bg);
      rectMode(CENTER);
      fill(0xFF82441A);
      rect(width/2, height/2, width/1.4f, height/1.4f);
      fill(0xFFFFB583);
      rect(width/2, height/2, width/1.5f, height/1.5f);
      rectMode(CORNER);
      menuStart.show();
      showPreview();
    }

    if (tempoGame>=tempoMax) {
      musica.stop();
      playerSprite = loadImage("ladrao_cansado.png");
      player.inventario.sortInventario();
      //player.abrirInventario = true;
      player.show();

      if (fim) {
        rectMode(CENTER);
        fill(0xFF82441A);
        rect(width/2.0f, height/2.0f, width/1.35f, height/1.35f, 25);
        fill(0xFFFFB583);
        rect(width/2.0f, height/2.0f, width/1.5f, height/1.5f);
        rectMode(CORNER);

        int[] aux = player.inventario.retornaQuantidade();
        float x = (width-width/1.5f)/2.0f;
        float y = (height-height/1.5f)/2.0f;

        for (int i = 0; i < 10; ++i) {
          image(moldura, x+(width/10.0f+x/10.0f)*((i+2)%2)+x/2.0f, x+(width/10.0f+x/10.0f)*(floor(i/2))+y/2.0f, width/10.0f, height/10.0f);
        }

        for (int i = itemSprites.length-1; i >= 0; --i) {
          image(itemSprites[i], x+(width/10.0f+x/10.0f)*((i+2)%2)+x/2.0f, x+(width/10.0f+x/10.0f)*(floor(i/2))+y/2.0f, width/10.0f, height/10.0f);
          fill(255);
          textSize(21);
          text(aux[i]+"x", x+(width/10.0f+x/10.0f)*((i+2)%2)+x/2.0f+width/25.0f, x+(width/10.0f+x/10.0f)*(floor(i/2))+y/2.0f+height/22.0f, width/10.0f, height/10.0f);
          textSize(20);
        }

        fill(0xFFE6955E);
        image(molduraPontuacao, (width-width/1.5f)/2.0f+width/1.5f/1.4f, (height-height/1.5f)/4.0f+height/5.0f, width/1.5f/2.0f, height/1.5f/4.0f);
        fill(255);
        textSize(45);
        text(nf(player.score, 4), (width-width/1.5f)/4.0f+width/1.5f/1.35f, (height-height/1.5f)/4.0f+height/4.5f);

        imageMode(CORNER);
        restart.visivel = true;
        exit.visivel = true;
        restart.show();
        exit.show();
        imageMode(CENTER);
      }
    }
  }
}

class Lista<T> { //Aqui é criado uma classe que recebe um tipo genérico
  Object[] objetos;
  int tamanho;

  Lista() {
    objetos = new Object[10];  // Dentro do construtor da lista criamos um vetor inicial com 10 posições
    tamanho = 0;  //Ao iniciar a lista, ela começa sem nenhum elemento salvo logo, seu conteudo é 0
  }

  public void add(T objeto) {
    if (tamanho==objetos.length){
      expandir();// Antes de adicionar um objeto, ocorre a verificação se a lista possui espaço suficiente para armazená-lo
    }
    objetos[tamanho] = (T) objeto;// Aqui temos a adição do objeto recebido em uma posição da lista
    tamanho++;
  }
  
  public void set(int index, T valor){
    if (index>=0 && index<tamanho) objetos[index] = valor;
  }
  
  public T get(int index) {
    if (index>=0 && index<tamanho) {  //Aqui verificamos se o index recebido por parâmetro existe na lista caso exista é retornado o objeto que está na posição pedida
      return (T)objetos[index];
    }
    else return null;  //Caso o index seja inválido, retorna null
  }
  
  public void swap(int id1, int id2){
    T aux = get(id1);
    set(id1, get(id2));
    set(id2, aux);
  }
  
  public void expandir() {
    Object[] aux = new Object[tamanho+1];  // Aqui é criado um vetor de objetos auxiliar com o tamanho = tamanho + 1
    System.arraycopy(objetos, 0, aux, 0, tamanho);  // Aqui é copiado os elementos anteriores para o vetor auxiliar
    objetos = aux;//  vetor objetos é atualizado para apontar para o vetor aux. Ou seja, o vetor objetos agora referencia o novo vetor expandido
  }

  public int size() {
    return tamanho;
  }
}
class botao {
  PVector pos;
  PVector tamanho; //Tamanho
  String nome;
  boolean visivel;
  boolean click;

  PImage img;
  boolean hasImage;

  botao(float x, float y, float tx, float ty, boolean visivel, String nome, PImage img) {
    pos = new PVector(x, y);
    tamanho = new PVector(tx, ty);
    this.visivel = visivel;
    this.nome = nome;
    this.img = img;
  }

  public void show() {
    if (visivel) {
      if (img!=null) {
        if (click) tint(100, 255);
        else tint(255, 255);
        if (visivel && mouseX>=pos.x && mouseX<=pos.x+tamanho.x && mouseY>=pos.y && mouseY<=pos.y+tamanho.y) tint(150, 255);
        image(img, pos.x, pos.y, tamanho.x, tamanho.y);
        tint(255, 255);
      } else {
        if (click) fill(100);
        else fill(255);
        stroke(1);
        rect(pos.x, pos.y, tamanho.x, tamanho.y);
        fill(0);
        text(nome, pos.x+tamanho.x/2.3f, pos.y+30);
      }
    }
  }

  public void clicked() {
    if (visivel && mouseX>=pos.x && mouseX<=pos.x+tamanho.x && mouseY>=pos.y && mouseY<=pos.y+tamanho.y) {
      click = true;
    }
  }
}
class checkBox {
  PVector pos;
  PVector tamanho; //Tamanho
  String nome;
  boolean visivel;
  boolean click;
  PImage imgUnchecked, imgChecked;

  checkBox(float x, float y, float tx, float ty, boolean visivel, String nome, PImage imgUnchecked, PImage imgChecked) {
    pos = new PVector(x, y);
    tamanho = new PVector(tx, ty);
    this.visivel = visivel;
    this.nome = nome;
    this.imgUnchecked = imgUnchecked;
    this.imgChecked = imgChecked;
  }

  public void show() {
    if (visivel) {
      if (imgUnchecked!=null && imgChecked!=null) {
        if(click) image(imgChecked, pos.x, pos.y, tamanho.x, tamanho.y);
        else  image(imgUnchecked, pos.x, pos.y, tamanho.x, tamanho.y);
      } else {
        stroke(1);
        if (click) fill(100);
        else fill(255);
        rect(pos.x, pos.y, tamanho.x, tamanho.y);
        fill(0);
        text(nome, pos.x+tamanho.x/2.3f, pos.y+30);
      }
    }
  }

  public void clicked() {
    if (visivel && mouseX>=pos.x && mouseX<=pos.x+tamanho.x && mouseY>=pos.y && mouseY<=pos.y+tamanho.y) {
      if (click) click = false;
      else click = true;
    }
  }
}
class inventario {
  Lista<Integer> inventario;

  inventario() {
    inventario = new Lista<Integer>();
  }

  public void addItem(item item) {
    inventario.add(item.valor);
  }

  public int getItem(int index) {
    return inventario.get(index);
  }

  public int[] retornaQuantidade() {
    int[] aux = new int[10];
    for(int i = 0; i < 10; ++i){
      for(int j = 0; j<inventario.size(); ++j){
        if(inventario.get(j)==(i+1)) aux[i]++;
      }
    }
    return aux;
  }

  public void sortInventario() {
    for (int i = inventario.size(); i >= 0; --i) {
      for (int j = 0; j < i-1; ++j) {
        if (inventario.get(j)>inventario.get(j+1)) {
          inventario.swap(j, j+1);
        }
      }
    }
  }

  public void show() {
    fill(100, 10);
    noStroke();
    rect(0, 0, width, height);
    float n = 6;
    float x = width/n;
    float y = height/n;
    for (int i = 0; i < inventario.size(); ++i) {
      image(itemSprites[inventario.get(i)-1], x*((i+n)%n)+x/2.0f, x*(floor(i/n))+y/2.0f, y, y);
    }
  }
}
class item {
  PVector pos;
  int valor;
  PImage img;
  boolean visivel;
  float a;

  //1 Marrom -- Bronze
  //2 Cinza -- Prata
  //3 Amarelo -- Ouro
  //4 Vermelho -- Rubi
  //5 Laranja -- Topázio
  //6 Roxo -- Ametista
  //7 Azul -- Safira
  //8 Rosa -- Flor de Cristal
  //9 Ciano -- Diamante
  //10 Indigo -- Cosmos

  item() {
    img = new PImage();
    geraItem();
  }

  public void updateTiles() {
    int x = (int)pos.x, y = (int)pos.y;
    for (int i = -1; i <= 1; ++i) {
      for (int j = -1; j <= 1; ++j) {
        grid[xC(x+i)][yC(y+j)].show();
      }
    }
  }

  public void geraItem() {
    PVector aux = posicaoAleatoria();
    while (grid[(int)aux.x][(int)aux.y].tipo==2 || (aux.x == player.pos.x && aux.y == player.pos.y)) {
      aux = posicaoAleatoria();
    }
    pos = new PVector(aux.x, aux.y);
    valor = valorAleatorio();
    visivel = true;
    if (valor >= 1 && valor<=itemSprites.length) img = itemSprites[valor-1];
  }

  public void show() {
    if (visivel) {
      updateTiles();
      imageMode(CORNER);
      image(img, pos.x*l+xOffset, pos.y*h+cos(a)*2+yOffset, l, h);
      a+=.3f;
    }
  }

  public void zeraItem() {
    updateTiles();
    visivel = false;
  }
}
class menu {
  PVector pos;
  PVector tamanho; //Tamanho
  boolean visivel;
  Lista<botao> botoes; //Trocar por lista depois
  Lista<checkBox> checkBoxes;
  Lista<textBox> textBoxes;
  
  menu(float x, float y, float tx, float ty, boolean visivel){
    pos = new PVector(x, y);
    tamanho = new PVector(tx, ty);
    botoes = new Lista<botao>();
    checkBoxes = new Lista<checkBox>();
    textBoxes = new Lista<textBox>();
    this.visivel = visivel;
  }
  
  public void addBotao(float x, float y, float tx, float ty, boolean visivel, String nome, PImage img){
      botoes.add(new botao(x, y, tx, ty, visivel, nome, img));
  }
  
  public void addcheckBox(float x, float y, float tx, float ty, boolean visivel, String nome, PImage imgUnchecked, PImage imgChecked){
      checkBoxes.add(new checkBox(x, y, tx, ty, visivel, nome, imgUnchecked, imgChecked));
  }
  
  public void addtextBox(float x, float y, float tx, float ty, boolean visivel, String nome, String txt, PImage img){
      textBoxes.add(new textBox(x, y, tx, ty, visivel, nome, txt, img));
  }
  
  public botao getBotao(String botao){
    for(int i = 0; i < botoes.size(); ++i){
      if(botao.equals(botoes.get(i).nome)) return botoes.get(i);
    }
    return null;
  }
  
  public checkBox getcheckBox(String checkBox){
    for(int i = 0; i < checkBoxes.size(); ++i){
      if(checkBox.equals(checkBoxes.get(i).nome)) return checkBoxes.get(i);
    }
    return null;
  }
  
  public textBox gettextBox(String textBox){
    for(int i = 0; i < textBoxes.size(); ++i){
      if(textBox.equals(textBoxes.get(i).nome)) return textBoxes.get(i);
    }
    return null;
  }
  
  public void show(){
    //noStroke();
    //fill(bg);
    //rect(pos.x, pos.y, tamanho.x, tamanho.y);
    for(int i = 0; i < botoes.size(); ++i){
      botoes.get(i).show();
    }
    for(int i = 0; i < checkBoxes.size(); ++i){
      checkBoxes.get(i).show();
    }
    for(int i = 0; i < textBoxes.size(); ++i){
      textBoxes.get(i).show();
    }
  }
}
class player {
  PVector pos;
  float a = 0;
  float animacao;
  int score = 0;
  inventario inventario;

  boolean flipped;
  boolean right, left, up, down; //Direções (Direita, Esquerda, Cima, Baixo)
  boolean abrirInventario;

  player(PVector pos) {
    this.pos = pos;
    inventario = new inventario();
  }


  public void updateTiles() {
    int x = (int)pos.x, y = (int)pos.y;
    int ix = (int)item.pos.x, iy = (int)item.pos.y;
    //Atualiza todos os arvoreSpritess em volta de uma vez, sem contar o item
    for (int i = -1; i <= 1; ++i) {
      for (int j = -1; j <= 1; ++j) {
        if (!(item.visivel && ix==xC(x+i) && iy==yC(y+j))) grid[xC(x+i)][yC(y+j)].show();
      }
    }
  }

  public void update() {
    int x = (int)pos.x, y = (int)pos.y;
    int dx = 0, dy = 0;

    //Checa se os espaços são válidos
    if (right && checarColisao(xC(x+1), y)) {
      dx += 1;
      flipped = true;
    }
    if (left && checarColisao(xC(x-1), y)) {
      dx += -1;
      flipped = false;
    }
    if (down && checarColisao(x, yC(y+1))) {
      dy += 1;
    }
    if (up && checarColisao(x, yC(y-1))) {
      dy += -1;
    }

    //Aplica nova posição
    if (checarColisao(xC(x+dx), yC(y+dy))) {
      updateTiles();
      pos = new PVector(xC(x+dx), yC(y+dy));
      if (item.visivel && x == item.pos.x && y == item.pos.y) {
        item.zeraItem();

        if (item.valor>=8) coleta[1].play();
        else coleta[0].play();

        score+=item.valor;
        inventario.addItem(item);
      }
    }
  }

  public void show() {
    updateTiles();
    imageMode(CENTER);
    pushMatrix();
    translate(pos.x*l+l/2+xOffset, pos.y*h+h/2+yOffset);
    if (flipped) scale(-1, 1);
    else scale(1, 1);
    if (game) {
      rotate(sin(a)/100*pitch.analyze()/((r+c)/2));
      image(playerSprite, 0, 0, l+animacao*map(cos(a), -1, 1, 0, 1)/l, h+animacao*map(cos(a), -1, 1, 0, 1)/h);
      animacao = pitch.analyze()/((r+c)/2);
      a+=.3f;
    } else {
      if (animacao<=1) {
        image(playerSprite, 0, 0, l+map(cos(a), -1, 1, 0, 1)*animacao, h+map(sin(a), -1, 1, 0, 1)*animacao);
      } else {
        if (animacao<1.5f) {
          playerSprite = loadImage("ladrao.png");
          image(playerSprite, 0, 0, l+animacao*map(cos(a), -1, 1, 0, 1)/l, h+animacao*map(cos(a), -1, 1, 0, 1)/h);
        } else if (animacao<1.7f) {
          image(playerSprite, 0, 0, l+map(cos(a), -1, 1, 0, 1)*animacao, h+map(sin(a), -1, 1, 0, 1)*animacao);
        } else if (animacao<2) {
          image(playerSprite, 0, 0, l+animacao*map(cos(a), -1, 1, 0, 1)/l, h+animacao*map(cos(a), -1, 1, 0, 1)/h);
        } else {
          image(playerSprite, 0, 0, l+map(cos(a), -1, 1, 0, 1)*animacao, h+map(sin(a), -1, 1, 0, 1)*animacao);
        }
      }
      if (animacao<=2) {
        animacao+=.1f;
      } else {
        if (!musicaFinal.isPlaying()) musicaFinal.play();
        fim = true;
      }

      a+=.5f;
    }
    popMatrix();

    if (abrirInventario) inventario.show();
  }
}
class textBox {
  PVector pos;
  PVector tamanho;
  String nome;
  String txt;
  boolean visivel;
  boolean click;
  PImage img;
  textBox(float x, float y, float tx, float ty, boolean visivel, String nome, String txt, PImage img) {
    pos = new PVector(x, y);
    tamanho = new PVector(tx, ty);
    this.visivel = visivel;
    this.nome = nome;
    this.txt = txt;
    this.img = img;
  }

  public void show() {
    if (visivel) {
      if (img!=null) {
        image(img, pos.x, pos.y, tamanho.x, tamanho.y);
      } else {
        if (click) fill(100);
        else fill(255);
        stroke(1);
        rect(pos.x, pos.y, tamanho.x, tamanho.y);
      }
      fill(0xFF82441A);
      textSize(30);
      text(txt, pos.x+tamanho.x/2.3f, pos.y+tamanho.y/1.35f);
      textSize(20);
    }
  }

  public void clicked() {
    if (visivel && mouseX>=pos.x && mouseX<=pos.x+tamanho.x && mouseY>=pos.y && mouseY<=pos.y+tamanho.y) {
      click = true;
    } else {
      click = false;
    }
  }
}
class tile {
  PVector pos;
  int tipo;

  tile(int x, int y, int tipo) {
    this.pos = new PVector(x, y);
    this.tipo = tipo;
  }

  public void show() {
    int x = (int)pos.x, y = (int)pos.y;
    if (tipo==2) {

      //Coloca Grama ou Terra abaixo da Árvore
      imageMode(CORNER);
      tint(0xFF74FF75, 255);
      //tint(lerpColor(#74FF75, #06B754, noise(x*escala, y*escala, seed)), 255);
      if (grid[x][yC(y-1)].tipo!=2) {
        if (grid[x][yC(y-1)].tipo==0 || grid[x][yC(y-1)].tipo==1) {
          image(gramaSprites[random(1)>.8f ? 1 : 0], x*l+xOffset, y*h+yOffset, l, h);
        }
        if (grid[x][yC(y-1)].tipo==3) {
          tint(255, 255);
          image(terraSprites[0], x*l+xOffset, y*h+yOffset, l, h);
        }
      } else if (grid[x][yC(y+1)].tipo!=2) {
        if (grid[x][yC(y+1)].tipo==0 || grid[x][yC(y+1)].tipo==1) {
          image(gramaSprites[random(1)>.8f ? 1 : 0], x*l+xOffset, y*h+yOffset, l, h);
        }
        if (grid[x][yC(y+1)].tipo==3) {
          tint(255, 255);
          image(terraSprites[0], x*l+xOffset, y*h+yOffset, l, h);
        }
      }

      //Organiza os sprites da Árvore para que estejam conectados
      tint(0, 255, 150, 255);
      if ((grid[xC(x+1)][y].tipo==2 || grid[xC(x-1)][y].tipo==2)) {
        if (grid[x][yC(y-1)].tipo==2) {
          if (grid[xC(x+1)][y].tipo==2) {
            image(arvoreSprites[5], x*l+xOffset, y*h+yOffset, l, h);
          } else {
            image(arvoreSprites[8], x*l+xOffset, y*h+yOffset, l, h);
          }
        } else {
          if (grid[xC(x+1)][y].tipo==2) {
            image(arvoreSprites[4], x*l+xOffset, y*h+yOffset, l, h);
          } else {
            image(arvoreSprites[9], x*l+xOffset, y*h+yOffset, l, h);
          }
        }
      } else {
        if (grid[x][yC(y-1)].tipo==2 && grid[x][yC(y+1)].tipo!=2) {
          image(arvoreSprites[7], x*l+xOffset, y*h+yOffset, l, h);
        } else {
          image(arvoreSprites[3], x*l+xOffset, y*h+yOffset, l, h);
        }
      }


      if (grid[xC(x+1)][y].tipo==2 && grid[xC(x-1)][y].tipo==2) {
        image(arvoreSprites[2], x*l+xOffset, y*h+yOffset, l, h);
      }

      if (grid[x][yC(y+1)].tipo==2) {
        if (grid[x][yC(y-1)].tipo==2 || grid[xC(x-1)][y].tipo==2 && grid[xC(x+1)][y].tipo==2) {
          image(arvoreSprites[0], x*l+xOffset, y*h+yOffset, l, h);
        }
        if (grid[xC(x+1)][y].tipo!=2 && grid[xC(x-1)][y].tipo!=2) {
          image(arvoreSprites[1], x*l+xOffset, y*h+yOffset, l, h);
        }
        if (grid[xC(x+1)][y].tipo!=2 && grid[xC(x-1)][y].tipo==2) {
          image(arvoreSprites[6], x*l+xOffset, y*h+yOffset, l, h);
        } else if (grid[xC(x+1)][y].tipo==2 && grid[xC(x-1)][y].tipo!=2) {
          image(arvoreSprites[10], x*l+xOffset, y*h+yOffset, l, h);
        }
      }
      tint(255, 255, 255, 255);
    } else {
      imageMode(CORNER);
      if (tipo==3) {
        image(terraSprites[0], x*l+xOffset, y*h+yOffset, l, h);
      } else {
        tint(0xFF74FF75, 255);
        image(gramaSprites[tipo], x*l+xOffset, y*h+yOffset, l, h);
      }
      tint(255, 255, 255, 255);
    }
  }
}


  public void settings() { size(750, 750); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "trabalho" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
